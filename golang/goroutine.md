# goroutine —— 协程

## 面试题

### 进程、线程和协程的不同？

分析：这种很明显的是一种逐步演化的路径。也就是`进程-线程-协程`总体而言可以看做是一种演化路线。

审视这个演化，就会发现它是朝着更轻量的方向演进的。于是结合需求和计算机的发展，就会发现：业务越来越复杂，计算机越来越强大，但是我们需要的确是越来越细粒度的资源分配。

进程演进到线程，共享了内存，但是线程可以被CPU单独调度；线程到协程，内存使用量更少了，多个协程绑定到一个线程，相当于大家平分了这个线程的 CPU。

以上这一段吹牛，如果面试记得，可以跟面试官聊。不记得就算了。

答案：（首先是标准答案）
1. 进程是资源分配的最小单位，而线程是 CPU 调度的单位，一个进程可以有多个线程。因为同一个进程内的线程共享了堆内存，所以在经常会引起并发编程问题；
2. 协程比线程更轻量级。线程的创建和销毁、调度还需要陷入到内核中，而协程可以认为完全是依赖于用户空间创建、销毁和调度的。同时协程相比线程，占据的资源更加小。

（其次，开始引申）目前来说，很多语言都开始尝试支持协程，主要是因为现在的很多业务都是短平快，或者是 IO 密集的，相比之下，线程也过于重了。

最有名的就是`goroutine`（实际上也不是最有名吧，不过都面试 go 了，就说最有名了），此外还有`kotlin`协程，`python`的协程。

### 类似问题
- 为什么要引入协程？看后面**为什么引入协程**，其实这两个问题基本上一样；


### 为什么要引入协程？

分析：`goroutine` 的引入，本质上还是为了规避一个问题：我又想有并发，但是我又不想陷入到内核里面去。于是就有了这个 `goroutine` 的东西。

该面试题的核心，就是协程“轻量”。这种轻量体现在两方面：
1. 所需要的资源更少
2. 创建销毁和调度更轻量，并不需要陷入内核

其实个人看法是大规模应用协程随着需求和计算机性能发展而来的大趋势。需求上，要求我们有更高的并发。而大多数并发执行的任务都是短平快，单独一个线程划不来，即便是使用线程池，也会带来频繁切换上下文的问题；而计算机性能提高，使得我们可以将整个计算机资源划分为更细粒度进行分配，两者叠加就是协程的出现。这一段算是个人体会，面试慎用。

答案：很简单，因为我们需要一个更轻量的东西来取代线程。（开始聊自己理解的起源）当前绝大多数系统处理的任务都是非常短平快的，或者是 IO 密集这种频繁触发上下文切换的任务。这导致我们如果使用线程，就不得不面临线程频繁切换，陷入内核的问题——这是一个极大的开销。

因此我们需要一个比线程更加轻量的东西。这个东西要具备两个特征：
1. 占有的资源小——我们都是小任务，不需要那么多资源；
2. 创建销毁和调度消耗少——小任务，还时常阻塞，所以调度一定要快要轻；

结合在一起就是`goroutine`了。

#### 类似问题
- 为什么有了线程池还是要有`goroutine`：线程池只是减轻了创建和销毁的开销，但是线程本身还是占有很多资源，上下文调度依然很重

### 怎么避免`goroutine`泄露？

分析：如果你不知道`goroutine`什么时候会结束，就不要使用`goroutine`。这是核心原则。讲完这个原则之后，可以讲一些如何做到“知道goroutine”何时结束。

大体上就是两个方向：
1. 超时控制
2. 信号通知。这一步基本上就是利用`channel`

这两个方向，基本上都离不开要使用`select`来配合。

然后刷两点可以回答”如何发现`goroutine`泄露“。

答案：避免`goroutine`泄露的核心原则是"Never start a goroutine without knowning when it will stop"（用英文会显得你比较专业，记不住可以替换为对应的中文）。

归根结底，就是要有办法控制住结束掉自己开启的`goroutine`。大体上有两类做法：
1. 超时控制，主要利用`context.Timeout`的特性；
2. 主动发信号给`goroutine`关闭。一般是要利用到`channel`的特性；

两种做法基本都要配合`select`特性来。要么是业务正常结束，退出`goroutine`，要么是超时，或者收到关闭信号，异常退出。

（开始讨论如何发现`goroutine`泄露）如果`goroutine`都不是自己开启的，那肯定是没得办法了。只能通过`runtime.NumGoroutine()`方法监控`goroutine`的数量来判断有没有泄露。如果`goroutine`一直在上涨，而且数量也很多，说明泄露很严重。而如果只是轻微泄露，比如说一万个`goroutine`里面泄露了十个，是很难看出来的。

（后面可以进一步引申，跳到**`goroutine`泄露的典型场景**）
（这个问题也可以针对`goroutine`泄露的典型场景来回答，比如说小心使用`channel`，正确使用`mutex`，防止业务一直阻塞等，不过略等于啥也没说）

#### 类似问题
- 如何发现`goroutine`泄露了

### `goroutine`泄露的典型场景

分析：这个问题答案来自煎鱼大佬的文章[跟读者聊 Goroutine 泄露的 N 种方法，真刺激！](https://blog.csdn.net/EDDYCJY/article/details/115535237)

PS：煎鱼大佬的文章都很浅显易懂，即便是难题也能说得很容易理解，大家可以多读读，他有一个公众号《脑子进煎鱼了》，可以关注。

记住，至少背下来里面的一个例子，防着面试官让你手写一个`goroutine`泄露的例子。

然后面试官让你看一段代码，如果有锁，就要怀疑死锁；如果有`channel`就要怀疑`goroutine`泄露；

其实`channel`的代码坑极多，在`channel`里面进一步讨论。

答：有：
- `channel`发送不接收
- `channel`接收不发送
- `nil channel`
- 慢等待
- 互斥锁忘记解锁
- 同步锁使用不当

（同样聊排查作为亮点）排查主要用`runtime.NumGoroutine`或者`pprof`工具。`pprof`会返回所有带有堆栈跟踪的`goroutine`列表。

#### 类似问题
- 可以写一个 `goroutine`泄露的例子吗？
- 或者面试官给你一段代码，让你看有什么问题

## Reference
[跟读者聊 Goroutine 泄露的 N 种方法，真刺激！](https://blog.csdn.net/EDDYCJY/article/details/115535237)
