# 其它

> 微服务细碎的问题就放在这里讨论

微服务的面试题，大体上可以分成：
1. 微服务本身的面试题。包括微服务的概念，为什么要微服务之类的；
2. 微服务治理的面试题。主要就是服务注册与发现，熔断限流之类的；
3. 微服务架构的面试题。微服务有什么部分，每个部分有什么用处，以及怎么设计；
4. 微服务选型的面试题。包括选择微服务框架，以及选择微服务依赖的第三方中间件的问题；

## 面试题目
### 微服务和 RESTful 的区别

分析：这个东西很多人都聊过，但是很多人都没说清楚。我给个“最终”答案：微服务是一种架构，而 RESTful API 是符合**REST**设计风格的 Web API。所以从这个角度来说，这两者根本不具备可比性。那么为什么面试官要问这个问题呢？大概率是他们公司内部有并存的微服务应用，和 RESTful 应用。

我们先来分析 RESTful，它是一种遵守了**REST**设计风格的 Web API，显然也有不遵守 REST 的。这部分我们一般就是简单描述为 Web 服务。

而微服务，一般是指以 RPC 为通信，结合了整个微服务治理的架构模式。实际上，微服务作为一种架构模式，其落地的选择是有很多的，除了这里说的 RPC，还有一种很重要的实现手段就是基于 Web API 的实现方式。

我们可以总结来说，微服务落地，最基本的通信的角度来说，可以是 RPC，也可以是 HTTP。而在 HTTP 之下，有一个子分类就是 RESTful。因此，微服务和 RESTful 的区别，核心就是：
1. 微服务是架构模式；
2. RESTful 是指符合 REST 规范的 Web API；
3. 微服务可以用 RESTful 来实现；

这里就基本上讨论清楚了，不过我们还可以刷一个亮点：RPC 本身也是可以用 RESTful 来实现的。于是我们可以加上第四点：有些微服务虽然是基于 RPC 来构建的，但是 RPC 本身又可以是用 RESTful 来实现的。

沿着这个思路：
1. 微服务用什么实现？RESTful 或者 RPC 都可以；
2. RPC 用什么实现？直接基于 TCP 或者基于 HTTP 都可以。

答案：
1. 微服务是架构模式；
2. RESTful 是指符合 REST 规范的 Web API；
3. 微服务可以用 RESTful 来实现；
4. （亮点）微服务的另外一种实现，是利用 RPC 来实现；而 RPC 可以直接基于 TCP 来实现，也可以基于 HTTP 来实现，所以也可以用 RESTful 来实现；（这里可能会引起面试官的兴趣，就是问你 RPC 有哪些实现思路）

（最后总结）微服务和 RESTful 总体来说是两种维度的东西。

（这里还有一个可能，就是面试官问你，RPC 和 RESTful 的区别，以为第四点我们聊到了微服务可以是 RPC 也可以是 RESTful）

### RPC 和 RESTful 的区别

分析：RPC 和 RESTful 的区别，前面的问题**微服务和 RESTful 的区别**我们已经提到了。 RPC 名字叫做远程过程调用，是一种远程通信协议。但凡是协议，就会有落地。那么 RPC 的落地就很百花争鸣了，不过主流就是两个流派：基于 HTTP 的和基于 TCP 的。前者的代表是 gRPC，后者的代表是 Dubbo。基于 HTTP 的，如果要是它的 API 设计也符合 REST 设计风格，那么就可以说，它是基于 RESTful 的。

后面我们可以稍微聊一下这两种实现方式的优劣对比，作为一个亮点。

答案：RPC 是远程通信协议，它的实现可以是基于 HTTP 的，也可以是基于 TCP 的。而 RESTful 是符合 REST 设计风格的 Web API。因此，如果一个 RPC 是基于 HTTP 的，并且 HTTP 的 API 设计是符合 REST 设计风格的，那么就可以说这个 RPC 是基于 RESTful 的。

它们也是两个不同维度的东西。一般来说，基于 TCP 的 RPC 实现更加复杂，但是可以从 TCP 层面上优化，因此性能会更好。而基于 HTTP 的则是实现非常简单，目前，基于 HTTP2 协议实现的 RPC 在性能上也很优秀，对于大部分应用来说，并不会触及它的性能上限（这里面是一个很大的误区，有很多人实际中，根本不考虑自己的实际情况，就使劲朝着高性能的角度去选型，其实大多数时候，我们都是和复杂度本身做斗争，而不是和性能作斗争）。

#### 类似问题
- RPC 实现思路。这个其实是一个很复杂的问题，不过只有在面试 RPC 中间件开发的时候才会涉及

### 微服务划分的粒度该如何确定？
分析：微服务划分粒度也可以说是模块划分粒度，其实是一个没准确答案的问题。很多时候，架构师划分模块自己都说不清楚为什么这么划分。

大体上的思路有几种：
- 按照 DDD 理论进行划分：这一类使用 DDD 中的限界上下文(bounded context)作为微服务的边界。也就是一个限界上下文内的自然就是一个微服务
- 按照敏捷团队理论：敏捷强调两个披萨团队，那么微服务的粒度就是一个团队的能力边界
- 按照复杂度理论：一个人能完全理解微服务的细节（或者说模块细节）
- 按照组织架构划分：这个就完全和技术没什么关系了，组织架构怎么设计，然后按照组织架构来分配系统模块

就我个人经验来看，没有哪个人是纯粹按照其中的一条标准来进行划分的。如果有人声称自己是按照 DDD 来划分，那就是在吹牛。因为模块划分，或者说微服务拆分，本身就是一个分蛋糕的过程，这个过程难免伴随组织架构调整。

如果是一个有人事权的 CTO 宣称自己能够按照 DDD 理论来分那还有点可能，不然就都是吹牛。

回答的时候可以回答标准的 DDD 理论思路。

答案：一般来说，微服务的划分可以利用 DDD 理论，一个限界上下文定义了微服务的边界，那么只需要按照限界上下文来进行划分就可以了。

不过那是理想情况。正常来说在真的划分微服务的时候还要考虑：
- 团队规模：微服务的边界不能超出团队的维护能力；
- 复杂度：最好微服务划分到一个人能够完全理解其中细节的地步。或者说，两三个人合在一起能够将服务的细节交代清楚的地步；
- 组织结构：如果不能够调整组织结构，那么组织结构会极大限制微服务划分，也就是康威定律，有什么样的组织架构就有什么样的系统；

一般服务拆分都需要比较强力的实权管理层来推进。

### 既然有了模块化，为什么还要微服务？

分析∶要回答这个问题，要理解模块化和微服务化的本质区别是什么。它们的本质区别
就是是否独立部署。其余的诸如微服务划分之类的这种东西，是完全可以照搬过去模块化。一般来说，我个人认为模块化应该是微服务化的前置条件。也就是如果模块化都没搞定，贸然上微服务，多半没有好结果。

所以，为什么要微服务化，就落在我们为什么非要独立部署上来，或者说独立部署究竟有什么好处。

- 首先我们想到，这是一种非常的隔离机制。因为独立部署直接就是物理隔离了。那么一个服务崩溃，或者服务所在的机器崩溃，都不会影响另外一个服务；
- 其次是微服务的独立升级。在模块化之下，如果要升级一个服务，或者修复一个 BUG，那需要找到所有使用这个模块的应用，挨个升级一遍。而在微服务之后，只需要维护者自己重新部署一下就可以。当然这也是一种双刃剑，因为很可能升级有BUG，然后导致别人的服务就莫名其妙崩溃了
- 易于横向扩展。单体模块化应用比起来，只需要扩展有需要的服务，而不必整个应用都横向扩展。
  
此外还有一些点要澄清一下∶

- 可靠性问题。这个其实是存疑的。因为虽然理论上来说，微服务独立部署天然提供了强隔离机制，以至于某些服务出故障，并不会影响别的服务。但是别忘了这里面很重要的一点微服务是独立部署的，微服务之间通信是网络通信，网络通信比本地调用脆弱多了。所以实际上，可靠性反而是下降的；
- 代码易维护这也是一个存疑的问题。大多数人的模块化，并没有单独分出去作为一个代码仓库，而是依旧集中在一个巨大的仓库里面，所以会带来这种错觉。实际上，模块化里面有一个重要的步骤就是做到代码的物理隔离。比如说 order 的代码在一个仓库，User的在一个仓库。如果这个代码拿出去独立部署，那就是微服务。如果通过依赖来引入，那就是模块化；
- 控制复杂度∶没得说， 和上面差不多。模块化也是通过分而治之， 来控制复杂度1
的，和微服务一样。所以实际上两者都能起到同样的效果。而且，微服务可以细分，模块也同样可以细分；
- 可测试性∶同上；


### 微服务和 SOA 对比

